#Write two methods: one that takes a Rational number as an argument, and 
#returns an Array of the denominators that are part of an Egyptian Fraction 
#representation of the number, and another that takes an Array of numbers in 
#the same format, and calculates the resulting Rational number. 

#You will need to use the Rational class provided by Ruby.

#An Egyptian Fraction is the sum of a series of distinct unit fractions 
#(no two are the same), such as:

# 1   1    1    1
# - + - + -- + --
# 2   3   13   15

#Every positive rational number can be written as an Egyptian fraction. 
#For example:
#     1   1   1   1
# 2 = - + - + - + -
#     1   2   3   6

#Problem create two methods:
  # 1. generate an array containing the denominators that are involved in
    # finding the eqyption fractions that sum to a Rational number as the
    # input
  #2. Takes an array of integers representing the denominators of an
    # egyption fraction and find the resulting rational number
#1.
  #Rules
  #input - Rational number
  #output - array of integers --> denominators

  #an egyption fraction can have an infinite number of combinations
  #aim to optomize the number of rational numbers necessary

  #no two denominators can be the same in an egyptian fraction
  # they are also Unit fractions meaning they always have 1 in the numerator

  # answers appear to brute force from (1...) some number that will eventually
  # sastify the final condition

#Data - Array

#Algo
#create an array to store the used denominators
# generate numbers and plug in as a denominator
  # if the input rational minus the generated rational number is negative
    # skip and generate another number
  # if the input minus the generated number is positive
    # minus the rational and keep the 'denomiator' in the array
  # continue until the input rational is 0/1 
# reutrn the array  

#2.
  #Problem
  # given an array of denominators; generate the rational number
  # that is the sum of all the rational numbers generated by the
  # array of denominators

  #Rules
  #input - Array of integers
  #output - Rational number

  # each input should be a unit fraction

  #Data - array

  #Algo
  #convert each element in the array into its proper unit fraction
  #sum the enire array to return the final number

require 'pry'

def egyptian(rational)
  result = []
  denominator = 1
  until rational == 0
    unit_frac = Rational(1,denominator)
    if rational - unit_frac >= 0
      rational -= unit_frac
      result << unit_frac.denominator
    end
    denominator += 1
  end
  result
end

def unegyptian(array)
  array.map {|denom| Rational(1, denom)}.sum
end



# binding.pry
p egyptian(Rational(2, 1)) == [1, 2, 3, 6]
p egyptian(Rational(137, 60)) == [1, 2, 3, 4, 5]
p egyptian(Rational(3, 1)) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 230, 57960]

p unegyptian(egyptian(Rational(1, 2))) == Rational(1, 2)
p unegyptian(egyptian(Rational(3, 4))) == Rational(3, 4)
p unegyptian(egyptian(Rational(39, 20))) == Rational(39, 20)
p unegyptian(egyptian(Rational(127, 130))) == Rational(127, 130)
p unegyptian(egyptian(Rational(5, 7))) == Rational(5, 7)
p unegyptian(egyptian(Rational(1, 1))) == Rational(1, 1)
p unegyptian(egyptian(Rational(2, 1))) == Rational(2, 1)
p unegyptian(egyptian(Rational(3, 1))) == Rational(3, 1)